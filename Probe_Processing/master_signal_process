import numpy as np
import matplotlib.pyplot as plt
from rtlsdr import RtlSdr
from scipy.signal import find_peaks

# Configure the SDR
sdr = RtlSdr()
sdr.sample_rate = 2e6  # 2.048 MS/s
sdr.center_freq = 125e6  # 125 MHz upconverter + 500 kHz
sdr.gain = 'auto'

# Read samples
num_samples = 1024 * 1024
samples = sdr.read_samples(num_samples)

# Close the SDR
sdr.close()

# # Find peaks in the real part of the samples
# peaks, _ = find_peaks(np.real(samples), height=threshold)

# Plot the SDR samples and highlight the peaks
t = np.arange(num_samples) / sdr.sample_rate
plt.figure(figsize=(12, 6))
plt.plot(t, np.abs(samples), label='Real')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('SDR Samples at 500 kHz with 125 MHz Upconverter (Noise Removed)')
plt.legend()
plt.show()

f = 1/t
plt.plot(np.abs(np.fft.fft(samples)), label='Real')
plt.xlabel('GETTING FREQQY WITH IT')
plt.ylabel('Amplitude')
plt.title('SDR Samples at 500 kHz with 125 MHz Upconverter (Noise Removed)')
plt.legend()
plt.show()

fftland = np.fft.fft(samples)
#print(fftland)
#filteredfft = np.zeros(fftland.shape)
#filteredfft[64:-64] = fftland[64:-64]
filteredfft = fftland
filter_length = 1024*8
filter = [0]*filter_length
filteredfft[:filter_length] = filter
filteredfft[-filter_length:] = filter
#print(filteredfft)
plt.plot(np.abs(filteredfft))
plt.xlabel('GETTING FREQQY WITH IT')
plt.ylabel('Amplitude')
plt.title('SDR Samples at 500 kHz with 125 MHz Upconverter (Noise Removed)')
plt.legend()
plt.show()

data = np.fft.ifft(filteredfft)
plt.plot(t, np.abs(data), label='Real')
# plt.plot(t[peaks], np.real(samples)[peaks], 'x', label='Peaks')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('SDR Samples at 500 kHz with 125 MHz Upconverter (Noise Removed)')
plt.legend()
plt.show()

absdata = np.abs(data)
cheese = np.array([1,1,1,1])
print(cheese.shape, data.shape)
result = np.convolve(absdata.T, cheese.T, mode = "same")
plt.plot(t, result, label='Real')
# plt.plot(t[peaks], np.real(samples)[peaks], 'x', label='Peaks')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('supreme betterness')
plt.legend()
plt.show()

# Extract I and Q components from the complex samples
I = np.real(data)  # In-phase component (real part)
Q = np.imag(data)  # Quadrature component (imaginary part)

# # Create a time vector (or sample indices)
# time = np.arange(len(data))/sdr.sample_rate

# # Create a 3D plot
# fig = plt.figure(figsize=(10, 6))
# ax = fig.add_subplot(111, projection='3d')

# # Plot I, Q, and time (or sample index) in 3D
# ax.scatter(I, Q, time, s=1, color='blue', alpha=0.5)

# # Labels and title
# ax.set_xlabel('In-Phase (I)')
# ax.set_ylabel('Quadrature (Q)')
# ax.set_zlabel('Time (samples)')
# ax.set_title('3D IQ Plot')

# plt.show()


signs = np.sign(I)
mayo = signs * np.abs(data)
plt.figure(figsize=(12, 6))
plt.plot(t, mayo, label='Condiments')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Multiplying IQ Samples with Negative')
plt.legend()
plt.show()



ketchup = np.convolve(mayo.T, cheese.T, mode = "same")
plt.plot(t, ketchup, label='Magnitude')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('supreme betterness')
plt.legend()
plt.show()

mustard = np.diff(mayo)
plt.plot(t[1:], mustard, label='Mayo')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('supreme betterness 2')
plt.legend()
plt.show()
