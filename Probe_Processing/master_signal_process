import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
import scipy.io

samples = np.load("probe_readings.npy")
sample_rate = 2e6
num_samples = 1024 * 1024


# Plot the collected samples, no extra gimicks
t = np.arange(num_samples) / sample_rate
plt.figure(figsize=(12, 6))
plt.plot(t, np.abs(samples), label='Absolute Value')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('SDR Samples at 500 kHz with 125 MHz Upconverter')
plt.legend()
plt.show()

# Plotting the Absolute Value of the FFT of the samples
plt.plot(np.abs(np.fft.fft(samples)), label='Absolute Value')
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.title('Frequency Spectrum of SDR Samples')
plt.legend()
plt.show()

# The previous plot had a HUGE spike at DC, which kind of makes readings quite redundant
# This can be fixed by basically making the readings at DC be zero, which is an easy way of applying a filter LOL

filteredfft = np.fft.fft(samples)
filter_length = 1024*8
filter = [0]*filter_length
filteredfft[:filter_length] = filter
filteredfft[-filter_length:] = filter

plt.plot(np.abs(filteredfft))
plt.xlabel('Frequency')
plt.ylabel('Amplitude')
plt.title('Frequency Spectrum of SDR Samples - DC Spike Filtered')
plt.legend()
plt.show()

# Since the DC Spike has been removed, the inverse FFT of the filtered dataset can be taken, and that presents us with clean values

data = np.fft.ifft(filteredfft)     # NOTE: The "data" variable is the raw samples, with the DC spike samples removed
plt.plot(t, np.abs(data), label='Real')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('SDR Samples - DC Spike Removed')
plt.legend()
plt.show()



absdata = np.abs(data)
cheese = np.array([1,1,1,1])
result = np.convolve(absdata.T, cheese.T, mode = "same")
plt.plot(t, result, label='Real')
# plt.plot(t[peaks], np.real(samples)[peaks], 'x', label='Peaks')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('supreme betterness')
plt.legend()
plt.show()

# Extract I and Q components from the complex samples
I = np.real(data)  # In-phase component (real part)
Q = np.imag(data)  # Quadrature component (imaginary part)

# # Create a time vector (or sample indices)
# time = np.arange(len(data))/sdr.sample_rate

# # Create a 3D plot
# fig = plt.figure(figsize=(10, 6))
# ax = fig.add_subplot(111, projection='3d')

# # Plot I, Q, and time (or sample index) in 3D
# ax.scatter(I, Q, time, s=1, color='blue', alpha=0.5)

# # Labels and title
# ax.set_xlabel('In-Phase (I)')
# ax.set_ylabel('Quadrature (Q)')
# ax.set_zlabel('Time (samples)')
# ax.set_title('3D IQ Plot')

# plt.show()


signs = np.sign(I)
mayo = signs * np.abs(data)
plt.figure(figsize=(12, 6))
plt.plot(t, mayo, label='Condiments')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Multiplying IQ Samples with Negative')
plt.legend()
plt.show()



ketchup = np.convolve(mayo.T, cheese.T, mode = "same")
plt.plot(t, ketchup, label='Magnitude')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('supreme betterness - integral')
plt.legend()
plt.show()


